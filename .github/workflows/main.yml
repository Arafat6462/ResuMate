# This is the name of our GitHub Actions workflow.
name: CI/CD for ResuMate

# This section defines when the workflow will run.
on:
  # We want it to run on every push to the 'master' branch.
  push:
    branches: [ "master" ]

# A workflow run is made up of one or more jobs that can run sequentially or in parallel.
jobs:
  # The first job is to build our Django Docker image and push it to Docker Hub.
  build-and-push:
    # The type of runner that the job will run on. We use the latest Ubuntu.
    runs-on: ubuntu-latest
    
    # Steps represent a sequence of tasks that will be executed as part of the job.
    steps:
      # Step 1: Check out the repository code so the workflow can access it.
      - name: Check out the repo
        uses: actions/checkout@v4

      # Step 2: Log in to Docker Hub.
      # We use the secrets we configured in the GitHub repository settings.
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      # Step 3: Extract metadata for Docker.
      # This step automatically creates tags for our image based on the git commit.
      # For example, it will create a tag with the short commit SHA and a 'latest' tag.
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_HUB_USERNAME }}/resumate

      # Step 4: Build the Docker image and push it to Docker Hub.
      # This uses the Dockerfile in our repository.
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  # The second job is to deploy the new image to our server.
  deploy:
    # This job will only run if the 'build-and-push' job completes successfully.
    needs: build-and-push
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: SSH into the Droplet and run the deployment script.
      - name: Deploy to Droplet
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DROPLET_HOST }}
          username: ${{ secrets.DROPLET_USER }}
          key: ${{ secrets.DROPLET_SSH_KEY }}
          # The script that will be executed on the server.
          script: |
            # Navigate to the app directory, creating it if it doesn't exist.
            cd /
            mkdir -p app
            cd app

            # Copy repository files to the server.
            # We need the docker-compose.prod.yml file.
            # This is a simple way to get it there. A more robust solution for many
            # config files might be a separate, private git repo for configuration.
            git clone https://github.com/${{ github.repository }}.git || (cd ${{ github.event.repository.name }} && git pull)
            
            # Create the .env file from GitHub secrets if it doesn't exist.
            # This is the secure way to handle our production environment variables.
            # The '|| true' ensures that the command doesn't fail if the file already exists.
            touch .env || true
            echo "DB_NAME=${{ secrets.DB_NAME }}" >> .env
            echo "DB_USER=${{ secrets.DB_USER }}" >> .env
            echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
            echo "DB_HOST=db" >> .env
            echo "DB_PORT=5432" >> .env
            echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env
            echo "OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}" >> .env
            echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> .env
            echo "PORT=8000" >> .env
            echo "ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}" >> .env

            # Log in to Docker Hub on the server.
            docker login -u ${{ secrets.DOCKER_HUB_USERNAME }} -p ${{ secrets.DOCKER_HUB_TOKEN }}
            
            # Pull the latest version of our application's image.
            docker pull ${{ secrets.DOCKER_HUB_USERNAME }}/resumate:latest
            
            # Stop the current running containers and start them again with the new image.
            # Docker Compose will automatically detect the new image and use it.
            # The '-f' flag specifies the production compose file.
            # The '-d' flag runs the containers in detached mode.
            docker compose -f ${{ github.event.repository.name }}/docker-compose.prod.yml up -d
            
            # Clean up old, unused Docker images to save disk space.
            docker image prune -f